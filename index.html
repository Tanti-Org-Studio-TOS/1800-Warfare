
<!DOCTYPE html>
<html lang="my">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>1800 Warfare: North America</title>

  <!-- Leaflet CSS (OSM tiles) -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p1nBbG6Y3pQ3Xr3D8rL2gYQmQyQz1r8u+H1QbYQ8S+M="
    crossorigin=""
  />

  <style>
    :root {
      --bg: #0b1220;
      --panel: rgba(20,24,30,0.85);
      --text: #e5e7eb;
      --accent: #3a86ff;
      --accent-2: #ef476f;
      --muted: #94a3b8;
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text);
      font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans Myanmar",sans-serif;}
    #map { height: 100vh; }
    #hud {
      position: absolute; top: 10px; left: 10px; z-index: 1000;
      width: 360px; background: var(--panel); backdrop-filter: blur(4px);
      border-radius: 10px; padding: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.35);
    }
    #hud .row { display: flex; gap: 8px; align-items: center; }
    #hud .space { justify-content: space-between; }
    #hud button, #hud select { padding: 6px 10px; border-radius: 6px; border: none; cursor: pointer; }
    #hud button { background: var(--accent); color: #fff; }
    #hud button:hover { background: #2f6fd6; }
    #hud select { background: #0f172a; color: var(--text); border: 1px solid #1f2937; }
    #log { margin-top: 8px; max-height: 180px; overflow: auto; font-size: 13px; line-height: 1.4;
      border-top: 1px dashed #334155; padding-top: 6px; }
    .leaflet-container { background: #091027; }
    .hidden { display: none; }

    #modal { position: fixed; inset: 0; z-index: 2000; background: rgba(0,0,0,0.55);
      display: grid; place-items: center; }
    .modal-card { width: min(520px, 92vw); background: #fff; color: #222;
      border-radius: 12px; padding: 16px; box-shadow: 0 12px 28px rgba(0,0,0,0.35); }
    .modal-actions { display: flex; justify-content: flex-end; gap: 10px; margin-top: 10px; }
    .modal-actions #conquerBtn { background: var(--accent-2); color: #fff; }
    .modal-actions #closeModalBtn { background: #eee; }
    .legend {
      display:flex; gap:8px; align-items:center; font-size:13px; margin-top:6px; color: var(--muted);
    }
    .key { width:12px; height:12px; border-radius:3px; display:inline-block; }
  </style>
</head>
<body>
  <!-- HUD -->
  <div id="hud" role="region" aria-label="Game HUD">
    <div class="row space">
      <div><strong>ချိန်</strong>: <span id="clock">00:00</span></div>
      <div><strong>ငွေ</strong>: <span id="coins">0</span></div>
      <div><strong>စွမ်းအား</strong>: <span id="menpower">0</span></div>
      <div><strong>ပိုင်နယ်နိမိတ်</strong>: <span id="ownedCount">0</span></div>
    </div>
    <div class="row space">
      <button id="endTurnBtn">End Turn</button>
      <button id="resetBtn">Reset</button>
    </div>
    <div class="legend" aria-label="Legend">
      <span class="key" style="background:#3a86ff"></span> Player
      <span class="key" style="background:#ef476f; margin-left:10px;"></span> AI
      <span class="key" style="background:#94a3b8; margin-left:10px;"></span> Neutral
    </div>
    <div id="log" aria-live="polite"></div>
  </div>

  <!-- Map -->
  <div id="map" aria-label="Map of North America in 1800"></div>

  <!-- Modal -->
  <div id="modal" class="hidden" role="dialog" aria-modal="true">
    <div class="modal-card">
      <h3 id="modal-title">သိမ်းမယ်?</h3>
      <div id="modal-body"></div>
      <div class="modal-actions">
        <button id="conquerBtn">Conquer</button>
        <button id="closeModalBtn">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-VWmFNfQVd6kZ8Z02ZJpH5cEjm4Cw2j1V2xCEMtNfCj0="
    crossorigin=""
  ></script>

  <!-- Turf.js (geospatial ops) -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>

  <script>
    // 1800 Warfare: North America
    // Real map + historical boundaries (circa 1800) via aourednik/historical-basemaps (GPL-3.0)
    // Base tiles: OpenStreetMap (Leaflet)
    // Sources:
    // - world_1800.geojson: https://github.com/aourednik/historical-basemaps/blob/master/geojson/world_1800.geojson
    // - Leaflet/OSM tiles: https://www.naturalearthdata.com/downloads/ (context), https://www.openstreetmap.org (tiles via Leaflet)
    //   Ref: Natural Earth (public domain, general mapping) & OSM contributors. (See docs) 

    const state = {
      timeSec: 0,
      coins: 60,
      men: 30,
      owners: {},      // code => 'player' | 'ai' | 'neutral'
      rules: {
        conquer_base_cost: 10,
        defense_multiplier: 1.4,
        men_per_conquer: 6,
        income_tick_seconds: 12,
        ai_tick_seconds: 15
      },
      map: null,
      layer: null,
      features: [],    // NA filtered features (countries/regions 1800)
      adjacency: {},   // code => [neighbor codes]
      selectedFeature: null
    };

    const $ = (id) => document.getElementById(id);
    function log(msg) {
      const el = $("log");
      const ts = new Date().toLocaleTimeString();
      el.innerHTML = `<div>[${ts}] ${msg}</div>` + el.innerHTML;
    }
    function updateHUD() {
      $("coins").textContent = state.coins;
      $("menpower").textContent = state.men;
      $("ownedCount").textContent = Object.values(state.owners).filter(o => o === "player").length;
      $("clock").textContent = new Date(state.timeSec * 1000).toISOString().substr(14,5);
    }

    const SAVE_KEY = "warfare1800-na";
    function saveGame() {
      localStorage.setItem(SAVE_KEY, JSON.stringify({
        timeSec: state.timeSec,
        coins: state.coins,
        men: state.men,
        owners: state.owners
      }));
    }
    function loadGame() {
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) return false;
      try {
        const sv = JSON.parse(raw);
        state.timeSec = sv.timeSec ?? 0;
        state.coins = sv.coins ?? 60;
        state.men = sv.men ?? 30;
        state.owners = sv.owners ?? {};
        log("Save data loaded.");
        return true;
      } catch(e) { console.warn(e); return false; }
    }

    function ownerColor(owner) {
      if (owner === "player") return "#3a86ff";
      if (owner === "ai") return "#ef476f";
      return "#94a3b8";
    }
    function styleFeature(f) {
      const code = codeOf(f);
      const owner = state.owners[code] || "neutral";
      return { color: "#0b1a2a", weight: 1, fillColor: ownerColor(owner), fillOpacity: 0.55 };
    }

    function openModal(title, bodyHtml, showConquer=false) {
      $("modal-title").textContent = title;
      $("modal-body").innerHTML = bodyHtml;
      $("modal").classList.remove("hidden");
      $("conquerBtn").classList.toggle("hidden", !showConquer);
    }
    function closeModal() {
      $("modal").classList.add("hidden");
      state.selectedFeature = null;
    }
    $("closeModalBtn").addEventListener("click", closeModal);

    function codeOf(feat) {
      const p = feat.properties || {};
      const name = (p.map_label || p.name || "unknown").trim();
      // world_1800 IDs may be absent => make stable code from bbox + name length
      const bb = turf.bbox(feat);
      const sig = `${bb[0].toFixed(2)}_${bb[1].toFixed(2)}_${bb[2].toFixed(2)}_${bb[3].toFixed(2)}`;
      return `${name}-${sig}`;
    }

    // ==== Gameplay numbers from area ====
    function areaDefenseIncome(feat) {
      try {
        const km2 = turf.area(feat) / 1_000_000;
        const defense = Math.max(4, Math.round(Math.log10(km2 + 10) * 6));
        const income = Math.max(3, Math.round(Math.sqrt(km2) / 220)); // NA scale
        return { defense, income };
      } catch {
        return { defense: 5, income: 4 };
      }
    }
    function conquerCost(feat) {
      const base = state.rules.conquer_base_cost || 10;
      const mult = state.rules.defense_multiplier || 1.4;
      const { defense } = areaDefenseIncome(feat);
      return Math.ceil(base + defense * mult);
    }

    function canConquer(code) {
      const adj = state.adjacency[code] || [];
      const hasOwnedNeighbors = adj.some(c => state.owners[c] === "player");
      const anyPlayer = Object.values(state.owners).some(v => v === "player");
      return hasOwnedNeighbors || !anyPlayer; // first pick can be anywhere
    }
    function doConquer(code, feat) {
      const cost = conquerCost(feat);
      const menNeed = state.rules.men_per_conquer || 6;
      if (state.coins < cost || state.men < menNeed) {
        log("ငွေ/စွမ်းအား မလုံလောက် — Conquer မအောင်မြင်");
        return false;
      }
      state.coins -= cost;
      state.men -= menNeed;
      state.owners[code] = "player";
      log(`သိမ်းပြီး — ${feat.properties?.map_label || feat.properties?.name || "Unknown"} | cost ${cost}, men ${menNeed}`);
      refreshLayer(); updateHUD(); saveGame();
      return true;
    }

    // ==== Income & AI ====
    function incomeTick() {
      let add = 0;
      state.features.forEach(f => {
        const code = codeOf(f);
        if (state.owners[code] === "player") add += areaDefenseIncome(f).income;
      });
      if (add > 0) {
        state.coins += add;
        state.men += Math.ceil(add / 3);
        log(`ဝင်ငွေ +${add} coin, စွမ်းား +${Math.ceil(add/3)}`);
      }
      updateHUD(); saveGame();
    }
    function aiStep() {
      const aiOwned = state.features.map(f => codeOf(f)).filter(c => state.owners[c] === "ai");
      const neutral = state.features.map(f => codeOf(f)).filter(c => (state.owners[c] || "neutral") === "neutral");
      let target = null;
      if (aiOwned.length === 0) {
        target = neutral[Math.floor(Math.random() * neutral.length)];
      } else {
        const candidates = neutral.filter(nc => aiOwned.some(ac => (state.adjacency[ac] || []).includes(nc)));
        target = (candidates.length ? candidates[Math.floor(Math.random()*candidates.length)] : null);
      }
      if (!target) return;
      state.owners[target] = "ai";
      const feat = state.features.find(f => codeOf(f) === target);
      log(`AI သိမ်းယူ — ${feat?.properties?.map_label || feat?.properties?.name || target}`);
      refreshLayer(); updateHUD(); saveGame();
    }

    // ==== Build adjacency (touching polygons) ====
    function buildAdjacency(features) {
      const adj = {};
      const boxes = features.map(f => ({ code: codeOf(f), bbox: turf.bbox(f) }));
      for (let i=0;i<features.length;i++) {
        const fi = features[i], ci = codeOf(fi); adj[ci] = adj[ci] || [];
        for (let j=i+1;j<features.length;j++) {
          const fj = features[j], cj = codeOf(fj);
          const bbi = boxes[i].bbox, bbj = boxes[j].bbox;
          const overlap = !(bbj[0] > bbi[2] || bbj[2] < bbi[0] || bbj[1] > bbi[3] || bbj[3] < bbi[1]);
          if (!overlap) continue;
          let touches = false;
          try { touches = turf.booleanIntersects(fi, fj); } catch { touches = false; }
          if (touches) { adj[ci].push(cj); adj[cj] = adj[cj] || []; adj[cj].push(ci); }
        }
      }
      return adj;
    }
    function refreshLayer(){ if(state.layer) state.layer.setStyle(styleFeature); }

    // ==== Fetch & Filter NA (1800) ====
    async function fetchWorld1800() {
      const remoteUrl = "https://raw.githubusercontent.com/aourednik/historical-basemaps/master/geojson/world_1800.geojson";
      const res = await fetch(remoteUrl);
      if (!res.ok) throw new Error("Failed to load world_1800.geojson");
      return await res.json();
    }
    function isNorthAmericaFeature(feat) {
      // North America + Caribbean + Central America (broad): lon -170..-30, lat 5..83
      const [minX, minY, maxX, maxY] = turf.bbox(feat);
      const width = maxX - minX, height = maxY - minY;
      const xIn = Math.max(0, Math.min(maxX, -30) - Math.max(minX, -170));
      const yIn = Math.max(0, Math.min(maxY, 83) - Math.max(minY, 5));
      const pct = (xIn/width) * (yIn/height);
      return Number.isFinite(pct) && pct > 0.30;
    }

    async function init() {
      // Map
      state.map = L.map("map", { minZoom: 3, maxZoom: 10, zoomControl:true }).setView([39,-101], 4);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "© OpenStreetMap contributors"
      }).addTo(state.map);

      // Data
      const world = await fetchWorld1800();            // historical (1800) dataset
      const featsNA = world.features.filter(isNorthAmericaFeature);

      // Keep many countries (USA/New Spain/British North America/Russian America/Greenland/Caribbean colonies…)
      state.features = featsNA;

      // Owners init
      const gotSave = loadGame();
      if (!gotSave) {
        state.features.forEach(f => { state.owners[codeOf(f)] = "neutral"; });

        // Seed AI 2 factions by random areas (to ensure "countries many" start state)
        const rndA = state.features[Math.floor(Math.random()*state.features.length)];
        const rndB = state.features[Math.floor(Math.random()*state.features.length)];
        state.owners[codeOf(rndA)] = "ai";
        state.owners[codeOf(rndB)] = "ai";
        saveGame();
      }

      // Adjacency
      state.adjacency = buildAdjacency(state.features);

      // Layer
      state.layer = L.geoJSON(state.features, {
        style: styleFeature,
        onEachFeature: (feature, layer) => {
          const nm = feature.properties?.map_label || feature.properties?.name || "Unknown";
          const { defense, income } = areaDefenseIncome(feature);
          layer.bindTooltip(`${nm}`, { direction:"top" });
          layer.on("click", () => {
            const code = codeOf(feature);
            const owner = state.owners[code] || "neutral";
            const cost = conquerCost(feature);
            if (owner === "player") {
              openModal(nm, `သင့်ပိုင် (Defense: <strong>${defense}</strong>, Income: <strong>${income}</strong>)`, false);
            } else if (!canConquer(code)) {
              openModal("Conquer မနိုင်", "Player ပိုင်နယ်နိမိတ်နီးပါး မရှိသေးပါ။ (first pick သည် နေရာမရွေးနိုင်)", false);
            } else {
              state.selectedFeature = feature;
              openModal(
                `သိမ်းမည်: ${nm}`,
                `ကုန်ကျစရိတ် <strong>${cost} coin</strong>, စွမ်းအားအသုံး <strong>${state.rules.men_per_conquer}</strong><br/>
                 Defense: <strong>${defense}</strong>, Income: <strong>${income}</strong>`,
                true
              );
            }
          });
        }
      }).addTo(state.map);

      // UI
      updateHUD();

      // Timers
      setInterval(() => {
        state.timeSec += (state.rules.income_tick_seconds || 12);
        incomeTick(); updateHUD();
      }, (state.rules.income_tick_seconds || 12) * 1000);

      setInterval(() => { aiStep(); }, (state.rules.ai_tick_seconds || 15) * 1000);

      // Buttons
      $("endTurnBtn").addEventListener("click", () => {
        state.timeSec += 30; incomeTick(); updateHUD();
      });
      $("resetBtn").addEventListener("click", () => {
        localStorage.removeItem(SAVE_KEY); location.reload();
      });

      $("conquerBtn").addEventListener("click", () => {
        if (!state.selectedFeature) return;
        const code = codeOf(state.selectedFeature);
        if (doConquer(code, state.selectedFeature)) closeModal();
      });

      log("Loaded North America (circa 1800) historical boundaries. Countries/regions: " + state.features.length);
    }

    init();
  </script>

  <!-- Credits (data sources): 
    - Historical boundaries (1800): aourednik/historical-basemaps (GPL-3.0) https://github.com/aourednik/historical-basemaps/blob/master/geojson/world_1800.geojson
    - Base tiles: OpenStreetMap via Leaflet (© OSM contributors)
    - General mapping context: Natural Earth (public domain) https://www.naturalearthdata.com/downloads/
  -->
</body>
</html>
